/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
/*
 * main.c - Auto-generated by Anjuta's Makefile project wizard
 * 
 */

#include <stdio.h>
#include <stdint.h>
#include "i2c-dev.h"
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <semaphore.h>
#include <pthread.h>
#include "i2c.h"
#include "utility.h"
#include "cmd.h"
#include "scr_template.h"

#define I2C_CLIENT_ID 0x37
#define I2C_CMD_RETRY_COUNT 20
#define I2C_CMD_RETRY_TIMOUT 20000
//#define I2C_SEM
#define I2C_MUTEX

extern uint8_t *_gpVersion;
extern uint8_t _gPicVersion;
static int32_t _gI2C_fd=-1;
static uint8_t _gPoll_Flag=0;
#if defined(I2C_SEM)
    static sem_t _gI2C_sem;
#endif
#if defined(I2C_MUTEX)
static pthread_mutex_t _gI2C_mutex;
#endif

int32_t i2c_init(void)
{
    uint8_t vI2C_Data[I2C_SMBUS_BLOCK_MAX]={0};
    uint8_t vRetry_Count=0;
    uint8_t vCmd[64]={0};

    system("rm -rf /var/tmp/oled/PIC24F_OK");
    _gI2C_fd = open( "/dev/i2c-0", O_RDWR );

    if( _gI2C_fd == -1 )
    {
        fprintf( stderr, "Failed to open /dev/i2c-0: \"%m\"\n" );
    	_gI2C_fd = open( "/dev/i2c-1", O_RDWR );
        if( _gI2C_fd == -1 ){
            fprintf( stderr, "Failed to open /dev/i2c-1: \"%m\"\n" );
            return -1;
	}
    }

    if( ioctl( _gI2C_fd, I2C_SLAVE, I2C_CLIENT_ID ) < 0 )
    {
        fprintf( stderr, "Failed to set slave address: \"%m\"\n" );
        close( _gI2C_fd );
        return -2;
    }

#if defined(I2C_MUTEX)
    if( 0 != pthread_mutex_init(&_gI2C_mutex, NULL) )
    {
        fprintf( stderr, "Mutex init failed: %m\n" );
        close( _gI2C_fd );
        return -3;
    }
#endif

    while(-1 == i2c_read_block(0, (uint8_t *)vI2C_Data))
    {
        printf("Retry %d\n", vRetry_Count);
        if(vRetry_Count++ >= 10)
        {
            fprintf( stderr, "Failed to read data form oled: \"%m\"\n" );
            close( _gI2C_fd );
            return -3;
        }
        usleep(100000);
    }

    system("touch /var/tmp/oled/PIC24F_OK");
    get_version();

    return 0;
}

int32_t i2c_release(void)
{
    uint8_t vpData[2]={0};

    vpData[0]=13;

    if(6 <= _gPicVersion)
        show_screen(SCR_TEMPLATE_10, vpData);
    else
        i2c_write_block(CMD_OLED_DISPLAY, 1, vpData);

    if( _gI2C_fd != -1 )
        close(_gI2C_fd);

    system("rm -rf /var/tmp/oled/PIC24F_OK");
#if defined(I2C_MUTEX)
    pthread_mutex_destroy(&_gI2C_mutex);
#endif
    return 0;
}

int32_t i2c_read_block(uint8_t reg_num, uint8_t *pData)
{
    uint8_t vCount=0;
    int32_t vDataLen=-1;
        
    if(_gI2C_fd < 0)
        return -1;

//    IN(DEBUG_MODEL_I2C, "");
#if defined(I2C_MUTEX)
    if(1 == _gPoll_Flag)
        return -1;
    _gPoll_Flag=1;
    pthread_mutex_lock(&_gI2C_mutex);
#endif

    do
    {
        if(0 != vCount)
            usleep(I2C_CMD_RETRY_TIMOUT);
        vDataLen = i2c_smbus_read_block_data(_gI2C_fd, reg_num, pData);

    }while(-1 == vDataLen && vCount++ < I2C_CMD_RETRY_COUNT );
#if defined(I2C_MUTEX)
    pthread_mutex_unlock(&_gI2C_mutex);
    _gPoll_Flag=0;
#endif

//    Mdump(DEBUG_MODEL_I2C, "read data : ", pData, vDataLen);

    return vDataLen;
}

int32_t i2c_write_block(uint8_t reg_num, uint8_t len, uint8_t *pData)
{
    uint8_t vCount=0;
    uint8_t vpData[33]={0};
    int32_t vRet=0;

    IN(DEBUG_MODEL_I2C, "len %d", len);

    if(_gI2C_fd < 0)
        return -1;
#if defined(I2C_MUTEX)
    _gPoll_Flag=1;
    pthread_mutex_lock(&_gI2C_mutex);
#endif
    Mdump(DEBUG_MODEL_I2C, "write data : ", pData, len);

    do
    {
        if(0 != vCount)
            usleep(I2C_CMD_RETRY_TIMOUT);
        memset(vpData, 0, sizeof(vpData));
        vRet = i2c_smbus_read_block_data(_gI2C_fd, CMD_INTERRUPT, vpData);
	
    }while((-1 == vRet || OBJECT_STATUS_PROCESSING == vpData[CMD_OBJECT_CONTROL]) && vCount++ < I2C_CMD_RETRY_COUNT );
    debug_print(DEBUG_MODEL_I2C, "Wait to write, vRet %d, cmd retry count %d, CMD_OBJECT_CONTROL %d\n", vRet, vCount, vpData[CMD_OBJECT_CONTROL]);
   vRet=-1;

    do
    {
        if(0 != vCount)
            usleep(I2C_CMD_RETRY_TIMOUT);
        else
            vCount=0;
        vRet = i2c_smbus_write_block_data(_gI2C_fd, reg_num, len, pData);

    }while(-1 == vRet && vCount++ < I2C_CMD_RETRY_COUNT );
    debug_print(DEBUG_MODEL_I2C, "Write finish vRet %d, cmd retry count %d\n", vRet, vCount);
#if defined(I2C_MUTEX)
    pthread_mutex_unlock(&_gI2C_mutex);
    _gPoll_Flag=0;
#endif
    OUT(DEBUG_MODEL_I2C, "vRet %d", vRet);
    return vRet;
}

void i2c_pec_enable( void )
{
    if( ioctl( _gI2C_fd, I2C_PEC, 1) < 0)
    { 
        fprintf( stderr, "Failed to enable PEC\n"); 
        exit(3);
    } 
}

void i2c_pec_disable( void )
{
    if( ioctl( _gI2C_fd, I2C_PEC, 0) < 0)
    { 
        fprintf( stderr, "Failed to disable PEC\n"); 
        exit(3);
    } 
}

