diff --git a/src/drivers/usb/core/Makefile b/src/drivers/usb/core/Makefile
index 507a4e1..96e3156 100644
--- a/src/drivers/usb/core/Makefile
+++ b/src/drivers/usb/core/Makefile
@@ -10,5 +10,6 @@ usbcore-y += devio.o notify.o generic.o quirks.o devices.o
 
 usbcore-$(CONFIG_PCI)		+= hcd-pci.o
 usbcore-$(CONFIG_USB_DEVICEFS)	+= inode.o
+usbcore-$(CONFIG_USB_ETRON_HUB) += ethub.o
 
 obj-$(CONFIG_USB)		+= usbcore.o
diff --git a/src/drivers/usb/core/config.c b/src/drivers/usb/core/config.c
index 83126b0..26678ca 100644
--- a/src/drivers/usb/core/config.c
+++ b/src/drivers/usb/core/config.c
@@ -123,21 +123,22 @@ static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 	}
 
 	if (usb_endpoint_xfer_isoc(&ep->desc))
-		max_tx = ep->desc.wMaxPacketSize * (desc->bMaxBurst + 1) *
-			(desc->bmAttributes + 1);
+		max_tx = (desc->bMaxBurst + 1) * (desc->bmAttributes + 1) *
+			le16_to_cpu(ep->desc.wMaxPacketSize);
 	else if (usb_endpoint_xfer_int(&ep->desc))
-		max_tx = ep->desc.wMaxPacketSize * (desc->bMaxBurst + 1);
+		max_tx = le16_to_cpu(ep->desc.wMaxPacketSize) *
+			(desc->bMaxBurst + 1);
 	else
 		max_tx = 999999;
-	if (desc->wBytesPerInterval > max_tx) {
+	if (le16_to_cpu(desc->wBytesPerInterval) > max_tx) {
 		dev_warn(ddev, "%s endpoint with wBytesPerInterval of %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to %d\n",
 				usb_endpoint_xfer_isoc(&ep->desc) ? "Isoc" : "Int",
-				desc->wBytesPerInterval,
+				le16_to_cpu(desc->wBytesPerInterval),
 				cfgno, inum, asnum, ep->desc.bEndpointAddress,
 				max_tx);
-		ep->ss_ep_comp.wBytesPerInterval = max_tx;
+		ep->ss_ep_comp.wBytesPerInterval = cpu_to_le16(max_tx);
 	}
 }
 
diff --git a/src/drivers/usb/core/hub.c b/src/drivers/usb/core/hub.c
index 93720bd..4b4a013 100644
--- a/src/drivers/usb/core/hub.c
+++ b/src/drivers/usb/core/hub.c
@@ -414,6 +414,11 @@ void usb_kick_khubd(struct usb_device *hdev)
 {
 	struct usb_hub *hub = hdev_to_hub(hdev);
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(hdev))
+		return ethub_usb_kick_kethubd(hdev);
+#endif
+
 	if (hub)
 		kick_khubd(hub);
 }
@@ -676,6 +681,11 @@ int usb_remove_device(struct usb_device *udev)
 	struct usb_hub *hub;
 	struct usb_interface *intf;
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(udev))
+		return ethub_usb_remove_device(udev);
+#endif
+
 	if (!udev->parent)	/* Can't remove a root hub */
 		return -EINVAL;
 	hub = hdev_to_hub(udev->parent);
@@ -1290,6 +1300,11 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	desc = intf->cur_altsetting;
 	hdev = interface_to_usbdev(intf);
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(hdev))
+		return -ENODEV;
+#endif
+
 	/* Hubs have proper suspend/resume support.  USB 3.0 device suspend is
 	 * different from USB 2.0/1.1 device suspend, and unfortunately we
 	 * don't support it yet.  So leave autosuspend disabled for USB 3.0
@@ -1421,6 +1436,11 @@ int usb_hub_claim_port(struct usb_device *hdev, unsigned port1, void *owner)
 	int rc;
 	void **powner;
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(hdev))
+		return ethub_usb_hub_claim_port(hdev, port1, owner);
+#endif
+
 	rc = find_port_owner(hdev, port1, &powner);
 	if (rc)
 		return rc;
@@ -1435,6 +1455,11 @@ int usb_hub_release_port(struct usb_device *hdev, unsigned port1, void *owner)
 	int rc;
 	void **powner;
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(hdev))
+		return ethub_usb_hub_release_port(hdev, port1, owner);
+#endif
+
 	rc = find_port_owner(hdev, port1, &powner);
 	if (rc)
 		return rc;
@@ -1449,6 +1474,11 @@ void usb_hub_release_all_ports(struct usb_device *hdev, void *owner)
 	int n;
 	void **powner;
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(hdev))
+		return ethub_usb_hub_release_all_ports(hdev, owner);
+#endif
+
 	n = find_port_owner(hdev, 1, &powner);
 	if (n == 0) {
 		for (; n < hdev->maxchild; (++n, ++powner)) {
@@ -1463,6 +1493,11 @@ bool usb_device_is_owned(struct usb_device *udev)
 {
 	struct usb_hub *hub;
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(udev))
+		return ethub_usb_device_is_owned(udev);
+#endif
+
 	if (udev->state == USB_STATE_NOTATTACHED || !udev->parent)
 		return false;
 	hub = hdev_to_hub(udev->parent);
@@ -1510,6 +1545,11 @@ void usb_set_device_state(struct usb_device *udev,
 	unsigned long flags;
 	int wakeup = -1;
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(udev))
+		return ethub_usb_set_device_state(udev, new_state);
+#endif
+
 	spin_lock_irqsave(&device_state_lock, flags);
 	if (udev->state == USB_STATE_NOTATTACHED)
 		;	/* do nothing */
@@ -1642,6 +1682,11 @@ void usb_disconnect(struct usb_device **pdev)
 	struct usb_device	*udev = *pdev;
 	int			i;
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(*pdev))
+		return ethub_usb_disconnect(pdev);
+#endif
+
 	if (!udev) {
 		pr_debug ("%s nodev\n", __func__);
 		return;
@@ -1867,6 +1912,11 @@ int usb_new_device(struct usb_device *udev)
 {
 	int err;
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(udev))
+		return ethub_usb_new_device(udev);
+#endif
+
 	if (udev->parent) {
 		/* Initialize non-root-hub device wakeup to disabled;
 		 * device (un)configuration controls wakeup capable
@@ -1935,6 +1985,11 @@ fail:
  */
 int usb_deauthorize_device(struct usb_device *usb_dev)
 {
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(usb_dev))
+		return ethub_usb_deauthorize_device(usb_dev);
+#endif
+
 	usb_lock_device(usb_dev);
 	if (usb_dev->authorized == 0)
 		goto out_unauthorized;
@@ -1962,6 +2017,11 @@ int usb_authorize_device(struct usb_device *usb_dev)
 {
 	int result = 0, c;
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(usb_dev))
+		return ethub_usb_authorize_device(usb_dev);
+#endif
+
 	usb_lock_device(usb_dev);
 	if (usb_dev->authorized == 1)
 		goto out_authorized;
@@ -2261,6 +2321,11 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 	int		port1 = udev->portnum;
 	int		status;
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(udev))
+		return ethub_usb_port_suspend(udev, msg);
+#endif
+
 	// dev_dbg(hub->intfdev, "suspend port %d\n", port1);
 
 	/* enable remote wakeup when appropriate; this lets the device
@@ -2437,6 +2502,11 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 	int		status;
 	u16		portchange, portstatus;
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(udev))
+		return ethub_usb_port_resume(udev, msg);
+#endif
+
 	/* Skip the initial Clear-Suspend step for a remote wakeup */
 	status = hub_port_status(hub, port1, &portstatus, &portchange);
 	if (status == 0 && !(portstatus & USB_PORT_STAT_SUSPEND))
@@ -2493,6 +2563,11 @@ int usb_remote_wakeup(struct usb_device *udev)
 {
 	int	status = 0;
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(udev))
+		return ethub_usb_remote_wakeup(udev);
+#endif
+
 	if (udev->state == USB_STATE_SUSPENDED) {
 		dev_dbg(&udev->dev, "usb %sresume\n", "wakeup-");
 		status = usb_autoresume_device(udev);
@@ -2510,6 +2585,11 @@ int usb_remote_wakeup(struct usb_device *udev)
 
 int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 {
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(udev))
+		return ethub_usb_port_suspend(udev, msg);
+#endif
+
 	return 0;
 }
 
@@ -2522,6 +2602,11 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 	int		status;
 	u16		portchange, portstatus;
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(udev))
+		return ethub_usb_port_resume(udev, msg);
+#endif
+
 	status = hub_port_status(hub, port1, &portstatus, &portchange);
 	status = check_port_resume_type(udev,
 			hub, port1, status, portchange, portstatus);
@@ -2595,6 +2680,11 @@ static int hub_reset_resume(struct usb_interface *intf)
  */
 void usb_root_hub_lost_power(struct usb_device *rhdev)
 {
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(rhdev))
+		return ethub_usb_root_hub_lost_power(rhdev);
+#endif
+
 	dev_warn(&rhdev->dev, "root hub lost power or was reset\n");
 	rhdev->reset_resume = 1;
 }
@@ -2666,6 +2756,11 @@ static int hub_port_debounce(struct usb_hub *hub, int port1)
 
 void usb_ep0_reinit(struct usb_device *udev)
 {
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(udev))
+		return ethub_usb_ep0_reinit(udev);
+#endif
+
 	usb_disable_endpoint(udev, 0 + USB_DIR_IN, true);
 	usb_disable_endpoint(udev, 0 + USB_DIR_OUT, true);
 	usb_enable_endpoint(udev, &udev->ep0, true);
@@ -3863,6 +3958,11 @@ int usb_reset_device(struct usb_device *udev)
 	int i;
 	struct usb_host_config *config = udev->actconfig;
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	if (usb_is_etron_hcd(udev))
+		return ethub_usb_reset_device(udev);
+#endif
+
 	if (udev->state == USB_STATE_NOTATTACHED ||
 			udev->state == USB_STATE_SUSPENDED) {
 		dev_dbg(&udev->dev, "device reset not allowed in state %d\n",
diff --git a/src/drivers/usb/core/message.c b/src/drivers/usb/core/message.c
index 5701e85..406b929 100644
--- a/src/drivers/usb/core/message.c
+++ b/src/drivers/usb/core/message.c
@@ -1139,11 +1139,20 @@ void usb_disable_interface(struct usb_device *dev, struct usb_interface *intf,
 void usb_disable_device(struct usb_device *dev, int skip_ep0)
 {
 	int i;
+	struct usb_hcd *hcd = bus_to_hcd(dev->bus);
 
 	/* getting rid of interfaces will disconnect
 	 * any drivers bound to them (a key side effect)
 	 */
 	if (dev->actconfig) {
+		/*
+		 * FIXME: In order to avoid self-deadlock involving the
+		 * bandwidth_mutex, we have to mark all the interfaces
+		 * before unregistering any of them.
+		 */
+		for (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++)
+			dev->actconfig->interface[i]->unregistering = 1;
+
 		for (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {
 			struct usb_interface	*interface;
 
@@ -1153,7 +1162,6 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 				continue;
 			dev_dbg(&dev->dev, "unregistering interface %s\n",
 				dev_name(&interface->dev));
-			interface->unregistering = 1;
 			remove_intf_ep_devs(interface);
 			device_del(&interface->dev);
 		}
@@ -1172,6 +1180,18 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 
 	dev_dbg(&dev->dev, "%s nuking %s URBs\n", __func__,
 		skip_ep0 ? "non-ep0" : "all");
+	if (hcd->driver->check_bandwidth) {
+		/* First pass: Cancel URBs, leave endpoint pointers intact. */
+		for (i = skip_ep0; i < 16; ++i) {
+			usb_disable_endpoint(dev, i, false);
+			usb_disable_endpoint(dev, i + USB_DIR_IN, false);
+		}
+		/* Remove endpoints from the host controller internal state */
+		mutex_lock(hcd->bandwidth_mutex);
+		usb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);
+		mutex_unlock(hcd->bandwidth_mutex);
+		/* Second pass: remove endpoint pointers */
+	}
 	for (i = skip_ep0; i < 16; ++i) {
 		usb_disable_endpoint(dev, i, true);
 		usb_disable_endpoint(dev, i + USB_DIR_IN, true);
@@ -1273,6 +1293,8 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 			interface);
 		return -EINVAL;
 	}
+	if (iface->unregistering)
+		return -ENODEV;
 
 	alt = usb_altnum_to_altsetting(iface, alternate);
 	if (!alt) {
diff --git a/src/drivers/usb/core/usb.c b/src/drivers/usb/core/usb.c
index d9d4b16..301f605 100644
--- a/src/drivers/usb/core/usb.c
+++ b/src/drivers/usb/core/usb.c
@@ -1036,10 +1036,19 @@ static int __init usb_init(void)
 	retval = usb_hub_init();
 	if (retval)
 		goto hub_init_failed;
+#if defined(CONFIG_USB_ETRON_HUB)
+	retval = ethub_init();
+	if (retval)
+		goto ethub_init_failed;
+#endif
 	retval = usb_register_device_driver(&usb_generic_driver, THIS_MODULE);
 	if (!retval)
 		goto out;
 
+#if defined(CONFIG_USB_ETRON_HUB)
+	ethub_cleanup();
+ethub_init_failed:
+#endif
 	usb_hub_cleanup();
 hub_init_failed:
 	usbfs_cleanup();
diff --git a/src/drivers/usb/core/usb.h b/src/drivers/usb/core/usb.h
index d450b74..ec383b5 100644
--- a/src/drivers/usb/core/usb.h
+++ b/src/drivers/usb/core/usb.h
@@ -50,6 +50,39 @@ extern void usb_hub_cleanup(void);
 extern int usb_major_init(void);
 extern void usb_major_cleanup(void);
 
+#if defined(CONFIG_USB_ETRON_HUB)
+extern int usb_is_etron_hcd(struct usb_device *udev);
+extern void ethub_usb_kick_kethubd(struct usb_device *hdev);
+extern int ethub_usb_remove_device(struct usb_device *udev);
+extern int ethub_usb_hub_claim_port(struct usb_device *hdev, unsigned port1, void *owner);
+extern int ethub_usb_hub_release_port(struct usb_device *hdev, unsigned port1, void *owner);
+extern void ethub_usb_hub_release_all_ports(struct usb_device *hdev, void *owner);
+extern bool ethub_usb_device_is_owned(struct usb_device *udev);
+extern void ethub_usb_set_device_state(struct usb_device *udev,
+		enum usb_device_state new_state);
+extern void ethub_usb_disconnect(struct usb_device **pdev);
+extern int ethub_usb_new_device(struct usb_device *udev);
+extern int ethub_usb_deauthorize_device(struct usb_device *usb_dev);
+extern int ethub_usb_authorize_device(struct usb_device *usb_dev);
+extern int ethub_usb_port_suspend(struct usb_device *udev, pm_message_t msg);
+extern int ethub_usb_port_resume(struct usb_device *udev, pm_message_t msg);
+extern void ethub_usb_root_hub_lost_power(struct usb_device *rhdev);
+extern void ethub_usb_ep0_reinit(struct usb_device *udev);
+extern int ethub_usb_reset_device(struct usb_device *udev);
+extern int ethub_init(void);
+extern void ethub_cleanup(void);
+
+#ifdef CONFIG_USB_SUSPEND
+extern int ethub_usb_remote_wakeup(struct usb_device *udev);
+#else
+static inline int ethub_usb_remote_wakeup(struct usb_device *udev)
+{
+	return 0;
+}
+#endif
+
+#endif
+
 #ifdef	CONFIG_PM
 
 extern int usb_suspend(struct device *dev, pm_message_t msg);
diff --git a/src/drivers/usb/host/Kconfig b/src/drivers/usb/host/Kconfig
index 0cf93e2..930d11c 100644
--- a/src/drivers/usb/host/Kconfig
+++ b/src/drivers/usb/host/Kconfig
@@ -4,6 +4,33 @@
 comment "USB Host Controller Drivers"
 	depends on USB
 
+config USB_ETRON_HCD
+	tristate "Etron HCD support"
+	depends on USB && PCI
+	help
+	  The Etron EJ168A chip is USB 3.0 host controller.
+
+	  Enable this option to support this chip in host controller mode.
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called etxhci-hcd.
+	  
+config USB_ETRON_HCD_DEBUGGING
+	bool "Debugging for the Etron host controller"
+	depends on USB_ETRON_HCD
+	---help---
+	  Say 'Y' to turn on debugging for the Etron host controller driver.
+	  This will spew debugging output, even in interrupt context.
+	  This should only be used for debugging Etron host driver bugs.
+
+	  If unsure, say N.
+
+config USB_ETRON_HUB
+	bool
+	depends on USB_ETRON_HCD
+	default y
+
 config USB_C67X00_HCD
 	tristate "Cypress C67x00 HCD support"
 	depends on USB
diff --git a/src/drivers/usb/host/Makefile b/src/drivers/usb/host/Makefile
index 624a362..d768cec 100644
--- a/src/drivers/usb/host/Makefile
+++ b/src/drivers/usb/host/Makefile
@@ -13,6 +13,9 @@ fhci-$(CONFIG_FHCI_DEBUG) += fhci-dbg.o
 
 xhci-hcd-y := xhci.o xhci-mem.o xhci-pci.o
 xhci-hcd-y += xhci-ring.o xhci-hub.o xhci-dbg.o
+etxhci-hcd-y := etxhci.o etxhci-mem.o etxhci-pci.o
+etxhci-hcd-y += etxhci-ring.o etxhci-hub.o etxhci-dbg.o
+etxhci-hcd-y += etxhci-ejxxx.o
 
 obj-$(CONFIG_USB_WHCI_HCD)	+= whci/
 
@@ -26,6 +29,7 @@ obj-$(CONFIG_USB_OHCI_HCD)	+= ohci-hcd.o
 obj-$(CONFIG_USB_UHCI_HCD)	+= uhci-hcd.o
 obj-$(CONFIG_USB_FHCI_HCD)	+= fhci.o
 obj-$(CONFIG_USB_XHCI_HCD)	+= xhci-hcd.o
+obj-$(CONFIG_USB_ETRON_HCD)	+= etxhci-hcd.o
 obj-$(CONFIG_USB_SL811_HCD)	+= sl811-hcd.o
 obj-$(CONFIG_USB_SL811_CS)	+= sl811_cs.o
 obj-$(CONFIG_USB_U132_HCD)	+= u132-hcd.o
diff --git a/src/drivers/usb/host/xhci-pci.c b/src/drivers/usb/host/xhci-pci.c
index a10494c..c66daef 100644
--- a/src/drivers/usb/host/xhci-pci.c
+++ b/src/drivers/usb/host/xhci-pci.c
@@ -169,6 +169,9 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	struct hc_driver *driver;
 	struct usb_hcd *hcd;
 
+	if (dev->vendor == 0x1b6f)
+		return -ENODEV;
+
 	driver = (struct hc_driver *)id->driver_data;
 	/* Register the USB 2.0 roothub.
 	 * FIXME: USB core must know to register the USB 2.0 roothub first.
diff --git a/src/drivers/usb/storage/uas.c b/src/drivers/usb/storage/uas.c
index 23f0dd9..4e2e704 100644
--- a/src/drivers/usb/storage/uas.c
+++ b/src/drivers/usb/storage/uas.c
@@ -8,11 +8,19 @@
  * Distributed under the terms of the GNU GPL, version two.
  */
 
+#include <linux/version.h>
 #include <linux/blkdev.h>
 #include <linux/slab.h>
 #include <linux/types.h>
+#include <linux/module.h>
 #include <linux/usb.h>
-#include <linux/usb/storage.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,34))
+#include <linux/usb/hcd.h>
+#else
+#include "../core/hcd.h"
+#endif
+#include <linux/usb_usual.h>
+#include <linux/usb/uas.h>
 
 #include <scsi/scsi.h>
 #include <scsi/scsi_dbg.h>
@@ -21,86 +29,76 @@
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_tcq.h>
 
-/* Common header for all IUs */
-struct iu {
-	__u8 iu_id;
-	__u8 rsvd1;
-	__be16 tag;
-};
-
-enum {
-	IU_ID_COMMAND		= 0x01,
-	IU_ID_STATUS		= 0x03,
-	IU_ID_RESPONSE		= 0x04,
-	IU_ID_TASK_MGMT		= 0x05,
-	IU_ID_READ_READY	= 0x06,
-	IU_ID_WRITE_READY	= 0x07,
-};
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37))
+#define USB_SC_SCSI	US_SC_SCSI
+#define USB_PR_BULK	US_PR_BULK
+#define USB_PR_UAS	US_PR_UAS
+#endif
 
-struct command_iu {
-	__u8 iu_id;
-	__u8 rsvd1;
-	__be16 tag;
-	__u8 prio_attr;
-	__u8 rsvd5;
-	__u8 len;
-	__u8 rsvd7;
-	struct scsi_lun lun;
-	__u8 cdb[16];	/* XXX: Overflow-checking tools may misunderstand */
-};
+//#define CONFIG_USB_UAS_ENABLE_TASK_MANAGEMENT 1
 
 /*
- * Also used for the Read Ready and Write Ready IUs since they have the
- * same first four bytes
+ * The r00-r01c specs define this version of the SENSE IU data structure.
+ * It's still in use by several different firmware releases.
  */
-struct sense_iu {
+struct sense_iu_r01 {
 	__u8 iu_id;
 	__u8 rsvd1;
 	__be16 tag;
-	__be16 status_qual;
-	__u8 status;
-	__u8 rsvd7[7];
 	__be16 len;
+	__u8 status;
+	__u8 service_response;
 	__u8 sense[SCSI_SENSE_BUFFERSIZE];
 };
 
 /*
- * The r00-r01c specs define this version of the SENSE IU data structure.
+ * The r02 specs define this version of the SENSE IU data structure.
  * It's still in use by several different firmware releases.
  */
-struct sense_iu_old {
+struct sense_iu_r02 {
 	__u8 iu_id;
 	__u8 rsvd1;
 	__be16 tag;
-	__be16 len;
 	__u8 status;
-	__u8 service_response;
+	__u8 rsvd2;
+	__be16 len;
 	__u8 sense[SCSI_SENSE_BUFFERSIZE];
 };
 
-enum {
-	CMD_PIPE_ID		= 1,
-	STATUS_PIPE_ID		= 2,
-	DATA_IN_PIPE_ID		= 3,
-	DATA_OUT_PIPE_ID	= 4,
-
-	UAS_SIMPLE_TAG		= 0,
-	UAS_HEAD_TAG		= 1,
-	UAS_ORDERED_TAG		= 2,
-	UAS_ACA			= 4,
-};
-
 struct uas_dev_info {
 	struct usb_interface *intf;
 	struct usb_device *udev;
-	int qdepth;
+	struct usb_anchor cmd_urbs;
+	struct usb_anchor sense_urbs;
+	struct usb_anchor data_urbs;
+	int qdepth, num_streams;
+	struct response_iu response;
 	unsigned cmd_pipe, status_pipe, data_in_pipe, data_out_pipe;
-	unsigned use_streams:1;
-	unsigned uas_sense_old:1;
+	unsigned long flags;
+#define UAS_FLIDX_USE_STREAMS	0
+#define UAS_FLIDX_RESETTING		1
+#define UAS_FLIDX_DISCONNECTING	2
+	unsigned long quirks;
+#define UAS_SENSE_IU_R01	(1 << 0)
+#define UAS_SENSE_IU_R02	(1 << 1)
+#define UAS_SENSE_IU_2R00	(1 << 2)
+#define UAS_NO_ATA_PASS_THRU	(1 << 3)
+#define UAS_NO_TEST_UNIT_READY	(1 << 4)
+#define UAS_INCOMPATIBLE_DEVICE	(1 << 31)
+	struct scsi_cmnd *cmnd;
+	spinlock_t lock;
 };
 
+#define UAS_TMF_TAG				1
+#define UAS_CMD_UNTAGGED_TAG	2
+#define UAS_CMD_TAG_OFFS		3
+
+#define UAS_PROBE	0
+#define UAS_DISCONNECT	1
+#define UAS_PREV_RESET	2
+#define UAS_POST_RESET	3
+
 enum {
-	ALLOC_STATUS_URB	= (1 << 0),
 	SUBMIT_STATUS_URB	= (1 << 1),
 	ALLOC_DATA_IN_URB	= (1 << 2),
 	SUBMIT_DATA_IN_URB	= (1 << 3),
@@ -108,6 +106,13 @@ enum {
 	SUBMIT_DATA_OUT_URB	= (1 << 5),
 	ALLOC_CMD_URB		= (1 << 6),
 	SUBMIT_CMD_URB		= (1 << 7),
+	COMMAND_INFLIGHT        = (1 << 8),
+	DATA_IN_URB_INFLIGHT    = (1 << 9),
+	DATA_OUT_URB_INFLIGHT   = (1 << 10),
+	COMMAND_COMPLETED       = (1 << 11),
+	COMMAND_ABORTED         = (1 << 12),
+	UNLINK_DATA_URBS		= (1 << 13),
+	IS_IN_WORK_LIST 		= (1 << 14),
 };
 
 /* Overrides scsi_pointer */
@@ -115,7 +120,6 @@ struct uas_cmd_info {
 	unsigned int state;
 	unsigned int stream;
 	struct urb *cmd_urb;
-	struct urb *status_urb;
 	struct urb *data_in_urb;
 	struct urb *data_out_urb;
 	struct list_head list;
@@ -124,94 +128,269 @@ struct uas_cmd_info {
 /* I hate forward declarations, but I actually have a loop */
 static int uas_submit_urbs(struct scsi_cmnd *cmnd,
 				struct uas_dev_info *devinfo, gfp_t gfp);
+static void uas_do_work(struct work_struct *work);
+static int uas_try_complete(struct scsi_cmnd *cmnd, const char *caller);
+static void uas_configure_endpoints(struct uas_dev_info *devinfo);
 
+static DECLARE_WORK(uas_work, uas_do_work);
 static DEFINE_SPINLOCK(uas_work_lock);
 static LIST_HEAD(uas_work_list);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+extern int usb_alloc_streams(struct usb_interface *interface,
+		struct usb_host_endpoint **eps, unsigned int num_eps,
+		unsigned int num_streams, gfp_t mem_flags);
+extern void usb_free_streams(struct usb_interface *interface,
+		struct usb_host_endpoint **eps, unsigned int num_eps,
+		gfp_t mem_flags);
+#endif
+
+extern void usb_run_bot_mode_notification(struct usb_device *hdev,
+		unsigned int portnum);
+
+static void uas_update_uas_device(struct usb_interface *intf, int type)
+{
+	struct usb_hcd *hcd;
+	struct usb_device *udev = interface_to_usbdev(intf);
+
+	hcd = bus_to_hcd(udev->bus);
+	if (hcd->driver->update_uas_device)
+		hcd->driver->update_uas_device(hcd, udev, type);
+}
+
+static void uas_unlink_data_urbs(struct uas_dev_info *devinfo,
+				 struct uas_cmd_info *cmdinfo)
+{
+	unsigned long flags;
+
+	/*
+	 * The UNLINK_DATA_URBS flag makes sure uas_try_complete
+	 * (called by urb completion) doesn't release cmdinfo
+	 * underneath us.
+	 */
+	spin_lock_irqsave(&devinfo->lock, flags);
+	cmdinfo->state |= UNLINK_DATA_URBS;
+	spin_unlock_irqrestore(&devinfo->lock, flags);
+
+	if (cmdinfo->data_in_urb)
+		usb_unlink_urb(cmdinfo->data_in_urb);
+	if (cmdinfo->data_out_urb)
+		usb_unlink_urb(cmdinfo->data_out_urb);
+
+	spin_lock_irqsave(&devinfo->lock, flags);
+	cmdinfo->state &= ~UNLINK_DATA_URBS;
+	spin_unlock_irqrestore(&devinfo->lock, flags);
+}
+
 static void uas_do_work(struct work_struct *work)
 {
 	struct uas_cmd_info *cmdinfo;
+	struct uas_cmd_info *temp;
 	struct list_head list;
+	unsigned long flags;
+	int err;
 
 	spin_lock_irq(&uas_work_lock);
 	list_replace_init(&uas_work_list, &list);
 	spin_unlock_irq(&uas_work_lock);
 
-	list_for_each_entry(cmdinfo, &list, list) {
+	list_for_each_entry_safe(cmdinfo, temp, &list, list) {
 		struct scsi_pointer *scp = (void *)cmdinfo;
 		struct scsi_cmnd *cmnd = container_of(scp,
 							struct scsi_cmnd, SCp);
-		uas_submit_urbs(cmnd, cmnd->device->hostdata, GFP_NOIO);
+		struct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;
+		spin_lock_irqsave(&devinfo->lock, flags);
+		err = uas_submit_urbs(cmnd, cmnd->device->hostdata, GFP_ATOMIC);
+		if (!err)
+			cmdinfo->state &= ~IS_IN_WORK_LIST;
+		spin_unlock_irqrestore(&devinfo->lock, flags);
+		if (err) {
+			list_del(&cmdinfo->list);
+			spin_lock_irq(&uas_work_lock);
+			list_add_tail(&cmdinfo->list, &uas_work_list);
+			spin_unlock_irq(&uas_work_lock);
+			schedule_work(&uas_work);
+		}
 	}
 }
 
-static DECLARE_WORK(uas_work, uas_do_work);
+static void uas_abort_work(struct uas_dev_info *devinfo)
+{
+	struct uas_cmd_info *cmdinfo;
+	struct uas_cmd_info *temp;
+	struct list_head list;
+	unsigned long flags;
+
+	spin_lock_irq(&uas_work_lock);
+	list_replace_init(&uas_work_list, &list);
+	spin_unlock_irq(&uas_work_lock);
+
+	spin_lock_irqsave(&devinfo->lock, flags);
+	list_for_each_entry_safe(cmdinfo, temp, &list, list) {
+		struct scsi_pointer *scp = (void *)cmdinfo;
+		struct scsi_cmnd *cmnd = container_of(scp,
+							struct scsi_cmnd, SCp);
+		struct uas_dev_info *di = (void *)cmnd->device->hostdata;
+
+		if (di == devinfo) {
+			cmdinfo->state |= COMMAND_ABORTED;
+			cmdinfo->state &= ~IS_IN_WORK_LIST;
+			if (test_bit(UAS_FLIDX_RESETTING, &devinfo->flags) ||
+				test_bit(UAS_FLIDX_DISCONNECTING, &devinfo->flags)) {
+				/* uas_stat_cmplt() will not do that
+				 * when a device reset is in
+				 * progress */
+				cmdinfo->state &= ~COMMAND_INFLIGHT;
+			}
+			uas_try_complete(cmnd, __func__);
+		} else {
+			/* not our uas device, relink into list */
+			list_del(&cmdinfo->list);
+			spin_lock_irq(&uas_work_lock);
+			list_add_tail(&cmdinfo->list, &uas_work_list);
+			spin_unlock_irq(&uas_work_lock);
+		}
+	}
+	spin_unlock_irqrestore(&devinfo->lock, flags);
+}
 
 static void uas_sense(struct urb *urb, struct scsi_cmnd *cmnd)
 {
-	struct sense_iu *sense_iu = urb->transfer_buffer;
+	struct Scsi_Host *shost = urb->context;
+	struct uas_dev_info *devinfo = (void *)shost->hostdata[0];
 	struct scsi_device *sdev = cmnd->device;
+	unsigned len;
+	int newlen;
+	char *data = urb->transfer_buffer;
 
-	if (urb->actual_length > 16) {
-		unsigned len = be16_to_cpup(&sense_iu->len);
-		if (len + 16 != urb->actual_length) {
-			int newlen = min(len + 16, urb->actual_length) - 16;
+	if (!(data[4] | data[6])) {
+		cmnd->result = SAM_STAT_GOOD;
+		return;
+	}
+
+	if (!(devinfo->quirks & 
+		(UAS_SENSE_IU_R01 | UAS_SENSE_IU_R02 | UAS_SENSE_IU_2R00))) {
+		if ((data[8] & 0x70) == 0x70) {
+			if (data[5]) {
+				devinfo->quirks |= UAS_SENSE_IU_R01;
+			} else {
+				devinfo->quirks |= UAS_SENSE_IU_R02;
+			}
+		} else {
+			devinfo->quirks |= UAS_SENSE_IU_2R00;
+		}
+
+		dev_info(&devinfo->udev->dev,
+			"%s: quirks = 0x%08lx\n", __func__, devinfo->quirks);
+	}
+
+	if (devinfo->quirks & UAS_SENSE_IU_R01) {
+		struct sense_iu_r01 *sense_iu_r01 = urb->transfer_buffer;
+
+		len = be16_to_cpup(&sense_iu_r01->len) - 2;
+		if (len + 8 != urb->actual_length) {
+			newlen = min(len + 8, urb->actual_length) - 8;
 			if (newlen < 0)
 				newlen = 0;
-			sdev_printk(KERN_INFO, sdev, "%s: urb length %d "
+			sdev_printk(KERN_DEBUG, sdev, "%s (r01): urb length %d "
 				"disagrees with IU sense data length %d, "
 				"using %d bytes of sense data\n", __func__,
 					urb->actual_length, len, newlen);
 			len = newlen;
 		}
-		memcpy(cmnd->sense_buffer, sense_iu->sense, len);
-	}
+		memcpy(cmnd->sense_buffer, sense_iu_r01->sense, len);
+		cmnd->result = sense_iu_r01->status;
+	} else if (devinfo->quirks & UAS_SENSE_IU_R02) {
+		struct sense_iu_r02 *sense_iu_r02 = urb->transfer_buffer;
 
-	cmnd->result = sense_iu->status;
-	if (sdev->current_cmnd)
-		sdev->current_cmnd = NULL;
-	cmnd->scsi_done(cmnd);
-	usb_free_urb(urb);
-}
-
-static void uas_sense_old(struct urb *urb, struct scsi_cmnd *cmnd)
-{
-	struct sense_iu_old *sense_iu = urb->transfer_buffer;
-	struct scsi_device *sdev = cmnd->device;
-
-	if (urb->actual_length > 8) {
-		unsigned len = be16_to_cpup(&sense_iu->len) - 2;
+		len = be16_to_cpup(&sense_iu_r02->len);
 		if (len + 8 != urb->actual_length) {
-			int newlen = min(len + 8, urb->actual_length) - 8;
+			newlen = min(len + 8, urb->actual_length) - 8;
+			if (newlen < 0)
+				newlen = 0;
+			sdev_printk(KERN_DEBUG, sdev, "%s (r02): urb length %d "
+				"disagrees with IU sense data length %d, "
+				"using %d bytes of sense data\n", __func__,
+					urb->actual_length, len, newlen);
+			len = newlen;
+		}
+		memcpy(cmnd->sense_buffer, sense_iu_r02->sense, len);
+		cmnd->result = sense_iu_r02->status;
+	} else {
+		struct sense_iu *sense_iu = urb->transfer_buffer;
+
+		len = be16_to_cpup(&sense_iu->len);
+		if (len + 16 != urb->actual_length) {
+			newlen = min(len + 16, urb->actual_length) - 16;
 			if (newlen < 0)
 				newlen = 0;
-			sdev_printk(KERN_INFO, sdev, "%s: urb length %d "
+			sdev_printk(KERN_DEBUG, sdev, "%s: urb length %d "
 				"disagrees with IU sense data length %d, "
 				"using %d bytes of sense data\n", __func__,
 					urb->actual_length, len, newlen);
 			len = newlen;
 		}
 		memcpy(cmnd->sense_buffer, sense_iu->sense, len);
+		cmnd->result = sense_iu->status;
 	}
+}
+
+static void uas_log_cmd_state(struct scsi_cmnd *cmnd, const char *caller)
+{
+	struct uas_cmd_info *ci = (void *)&cmnd->SCp;
 
-	cmnd->result = sense_iu->status;
-	if (sdev->current_cmnd)
-		sdev->current_cmnd = NULL;
+	scmd_printk(KERN_INFO, cmnd, "%s cmd:%p (0x%02x) tag %d, inflight:"
+		    "%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",
+		    caller, cmnd, cmnd->cmnd[0], cmnd->request->tag,
+		    (ci->state & SUBMIT_STATUS_URB)     ? " s-st"  : "",
+		    (ci->state & ALLOC_DATA_IN_URB)     ? " a-in"  : "",
+		    (ci->state & SUBMIT_DATA_IN_URB)    ? " s-in"  : "",
+		    (ci->state & ALLOC_DATA_OUT_URB)    ? " a-out" : "",
+		    (ci->state & SUBMIT_DATA_OUT_URB)   ? " s-out" : "",
+		    (ci->state & ALLOC_CMD_URB)         ? " a-cmd" : "",
+		    (ci->state & SUBMIT_CMD_URB)        ? " s-cmd" : "",
+		    (ci->state & COMMAND_INFLIGHT)      ? " CMD"   : "",
+		    (ci->state & DATA_IN_URB_INFLIGHT)  ? " IN"    : "",
+		    (ci->state & DATA_OUT_URB_INFLIGHT) ? " OUT"   : "",
+		    (ci->state & COMMAND_COMPLETED)     ? " done"  : "",
+		    (ci->state & COMMAND_ABORTED)		? " abort" : "",
+		    (ci->state & UNLINK_DATA_URBS)		? " unlink": "",
+		    (ci->state & IS_IN_WORK_LIST)		? " work"  : "");
+}
+
+static int uas_try_complete(struct scsi_cmnd *cmnd, const char *caller)
+{
+	struct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;
+
+	if (cmdinfo->state & (COMMAND_INFLIGHT |
+			      DATA_IN_URB_INFLIGHT |
+		          DATA_OUT_URB_INFLIGHT |
+		          UNLINK_DATA_URBS))
+		return -EBUSY;
+	BUG_ON(cmdinfo->state & COMMAND_COMPLETED);
+	cmdinfo->state |= COMMAND_COMPLETED;
+	usb_free_urb(cmdinfo->data_in_urb);
+	usb_free_urb(cmdinfo->data_out_urb);
+	if (cmdinfo->state & COMMAND_ABORTED) {
+		scmd_printk(KERN_INFO, cmnd, "abort completed\n");
+		cmnd->result = DID_ABORT << 16;
+	}
 	cmnd->scsi_done(cmnd);
-	usb_free_urb(urb);
+	return 0;
 }
 
 static void uas_xfer_data(struct urb *urb, struct scsi_cmnd *cmnd,
-							unsigned direction)
+			  unsigned direction)
 {
 	struct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;
 	int err;
 
-	cmdinfo->state = direction | SUBMIT_STATUS_URB;
+	cmdinfo->state |= direction | SUBMIT_STATUS_URB;
 	err = uas_submit_urbs(cmnd, cmnd->device->hostdata, GFP_ATOMIC);
 	if (err) {
 		spin_lock(&uas_work_lock);
 		list_add_tail(&cmdinfo->list, &uas_work_list);
+		cmdinfo->state |= IS_IN_WORK_LIST;
 		spin_unlock(&uas_work_lock);
 		schedule_work(&uas_work);
 	}
@@ -220,9 +399,11 @@ static void uas_xfer_data(struct urb *urb, struct scsi_cmnd *cmnd,
 static void uas_stat_cmplt(struct urb *urb)
 {
 	struct iu *iu = urb->transfer_buffer;
-	struct scsi_device *sdev = urb->context;
-	struct uas_dev_info *devinfo = sdev->hostdata;
+	struct Scsi_Host *shost = urb->context;
+	struct uas_dev_info *devinfo = (void *)shost->hostdata[0];
 	struct scsi_cmnd *cmnd;
+	struct uas_cmd_info *cmdinfo;
+	unsigned long flags;
 	u16 tag;
 
 	if (urb->status) {
@@ -231,22 +412,46 @@ static void uas_stat_cmplt(struct urb *urb)
 		return;
 	}
 
-	tag = be16_to_cpup(&iu->tag) - 1;
-	if (sdev->current_cmnd)
-		cmnd = sdev->current_cmnd;
+	if (test_bit(UAS_FLIDX_RESETTING, &devinfo->flags) ||
+		test_bit(UAS_FLIDX_DISCONNECTING, &devinfo->flags)) {
+		usb_free_urb(urb);
+		return;
+	}
+
+	spin_lock_irqsave(&devinfo->lock, flags);
+	tag = be16_to_cpup(&iu->tag);
+	if (tag == UAS_TMF_TAG)
+		cmnd = NULL;
+	else if (tag == UAS_CMD_UNTAGGED_TAG)
+		cmnd = devinfo->cmnd;
 	else
-		cmnd = scsi_find_tag(sdev, tag);
-	if (!cmnd)
+		cmnd = scsi_host_find_tag(shost, tag - UAS_CMD_TAG_OFFS);
+
+	if (!cmnd) {
+		if (iu->iu_id == IU_ID_RESPONSE) {
+			/* store results for uas_eh_task_mgmt() */
+			memcpy(&devinfo->response, iu, sizeof(devinfo->response));
+		}
+		usb_free_urb(urb);
+		spin_unlock_irqrestore(&devinfo->lock, flags);
 		return;
+	}
 
+	cmdinfo = (void *)&cmnd->SCp;
 	switch (iu->iu_id) {
 	case IU_ID_STATUS:
-		if (urb->actual_length < 16)
-			devinfo->uas_sense_old = 1;
-		if (devinfo->uas_sense_old)
-			uas_sense_old(urb, cmnd);
-		else
-			uas_sense(urb, cmnd);
+		if (devinfo->cmnd == cmnd)
+			devinfo->cmnd = NULL;
+
+		uas_sense(urb, cmnd);
+		if (cmnd->result != 0) {
+			/* cancel data transfers on error */
+			spin_unlock_irqrestore(&devinfo->lock, flags);
+			uas_unlink_data_urbs(devinfo, cmdinfo);
+			spin_lock_irqsave(&devinfo->lock, flags);
+		}
+		cmdinfo->state &= ~COMMAND_INFLIGHT;
+		uas_try_complete(cmnd, __func__);
 		break;
 	case IU_ID_READ_READY:
 		uas_xfer_data(urb, cmnd, SUBMIT_DATA_IN_URB);
@@ -258,37 +463,80 @@ static void uas_stat_cmplt(struct urb *urb)
 		scmd_printk(KERN_ERR, cmnd,
 			"Bogus IU (%d) received on status pipe\n", iu->iu_id);
 	}
+	usb_free_urb(urb);
+	spin_unlock_irqrestore(&devinfo->lock, flags);
 }
 
 static void uas_data_cmplt(struct urb *urb)
 {
-	struct scsi_data_buffer *sdb = urb->context;
-	sdb->resid = sdb->length - urb->actual_length;
-	usb_free_urb(urb);
+	struct scsi_cmnd *cmnd = urb->context;
+	struct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;
+	struct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;
+	struct scsi_data_buffer *sdb = NULL;
+	unsigned long flags;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+	kfree(urb->sg);
+#endif
+
+	spin_lock_irqsave(&devinfo->lock, flags);
+	if (cmdinfo->data_in_urb == urb) {
+		sdb = scsi_in(cmnd);
+		cmdinfo->state &= ~DATA_IN_URB_INFLIGHT;
+	} else if (cmdinfo->data_out_urb == urb) {
+		sdb = scsi_out(cmnd);
+		cmdinfo->state &= ~DATA_OUT_URB_INFLIGHT;
+	}
+	BUG_ON(sdb == NULL);
+	if (urb->status) {
+		/* error: no data transfered */
+		sdb->resid = sdb->length;
+	} else {
+		sdb->resid = sdb->length - urb->actual_length;
+	}
+	uas_try_complete(cmnd, __func__);
+	spin_unlock_irqrestore(&devinfo->lock, flags);
 }
 
 static struct urb *uas_alloc_data_urb(struct uas_dev_info *devinfo, gfp_t gfp,
-				unsigned int pipe, u16 stream_id,
-				struct scsi_data_buffer *sdb,
-				enum dma_data_direction dir)
+				      unsigned int pipe, u16 stream_id,
+				      struct scsi_cmnd *cmnd,
+				      enum dma_data_direction dir)
 {
 	struct usb_device *udev = devinfo->udev;
 	struct urb *urb = usb_alloc_urb(0, gfp);
+	struct scsi_data_buffer *sdb = (dir == DMA_FROM_DEVICE)
+		? scsi_in(cmnd) : scsi_out(cmnd);
 
 	if (!urb)
 		goto out;
-	usb_fill_bulk_urb(urb, udev, pipe, NULL, sdb->length, uas_data_cmplt,
-									sdb);
-	if (devinfo->use_streams)
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+	urb->sg = kzalloc(sizeof(struct usb_sg_request), gfp);
+	if (urb->sg == NULL) {
+		usb_free_urb(urb);
+		urb = NULL;
+		goto out;
+	}
+#endif
+
+	usb_fill_bulk_urb(urb, udev, pipe, NULL, sdb->length,
+			  uas_data_cmplt, cmnd);
+	if (test_bit(UAS_FLIDX_USE_STREAMS, &devinfo->flags))
 		urb->stream_id = stream_id;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+	urb->num_sgs = sdb->table.nents;
+	urb->sg->sg = sdb->table.sgl;
+#else
 	urb->num_sgs = udev->bus->sg_tablesize ? sdb->table.nents : 0;
 	urb->sg = sdb->table.sgl;
+#endif
  out:
 	return urb;
 }
 
 static struct urb *uas_alloc_sense_urb(struct uas_dev_info *devinfo, gfp_t gfp,
-					struct scsi_cmnd *cmnd, u16 stream_id)
+				       struct Scsi_Host *shost, u16 stream_id)
 {
 	struct usb_device *udev = devinfo->udev;
 	struct urb *urb = usb_alloc_urb(0, gfp);
@@ -302,7 +550,7 @@ static struct urb *uas_alloc_sense_urb(struct uas_dev_info *devinfo, gfp_t gfp,
 		goto free;
 
 	usb_fill_bulk_urb(urb, udev, devinfo->status_pipe, iu, sizeof(*iu),
-						uas_stat_cmplt, cmnd->device);
+						uas_stat_cmplt, shost);
 	urb->stream_id = stream_id;
 	urb->transfer_flags |= URB_FREE_BUFFER;
  out:
@@ -333,7 +581,10 @@ static struct urb *uas_alloc_cmd_urb(struct uas_dev_info *devinfo, gfp_t gfp,
 		goto free;
 
 	iu->iu_id = IU_ID_COMMAND;
-	iu->tag = cpu_to_be16(stream_id);
+	if (blk_rq_tagged(cmnd->request))
+		iu->tag = cpu_to_be16(cmnd->request->tag + UAS_CMD_TAG_OFFS);
+	else
+		iu->tag = cpu_to_be16(UAS_CMD_UNTAGGED_TAG);
 	iu->prio_attr = UAS_SIMPLE_TAG;
 	iu->len = len;
 	int_to_scsilun(sdev->lun, &iu->lun);
@@ -349,30 +600,90 @@ static struct urb *uas_alloc_cmd_urb(struct uas_dev_info *devinfo, gfp_t gfp,
 	return NULL;
 }
 
+#if defined(CONFIG_USB_UAS_ENABLE_TASK_MANAGEMENT)
+static int uas_submit_task_urb(struct scsi_cmnd *cmnd, gfp_t gfp,
+			       u8 function, u16 stream_id)
+{
+	struct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;
+	struct usb_device *udev = devinfo->udev;
+	struct urb *urb = usb_alloc_urb(0, gfp);
+	struct task_mgmt_iu *iu;
+	int err = -ENOMEM;
+
+	if (!urb)
+		goto err;
+
+	iu = kzalloc(sizeof(*iu), gfp);
+	if (!iu)
+		goto err;
+
+	iu->iu_id = IU_ID_TASK_MGMT;
+	iu->tag = cpu_to_be16(stream_id);
+	int_to_scsilun(cmnd->device->lun, &iu->lun);
+
+	iu->function = function;
+	switch (function) {
+	case TMF_ABORT_TASK:
+		if (blk_rq_tagged(cmnd->request))
+			iu->task_tag = cpu_to_be16(cmnd->request->tag + UAS_CMD_TAG_OFFS);
+		else
+			iu->task_tag = cpu_to_be16(UAS_CMD_UNTAGGED_TAG);
+		break;
+	}
+
+	usb_fill_bulk_urb(urb, udev, devinfo->cmd_pipe, iu, sizeof(*iu),
+			  usb_free_urb, NULL);
+	urb->transfer_flags |= URB_FREE_BUFFER;
+
+	err = usb_submit_urb(urb, gfp);
+	if (err)
+		goto err;
+	usb_anchor_urb(urb, &devinfo->cmd_urbs);
+
+	return 0;
+
+err:
+	usb_free_urb(urb);
+	return err;
+}
+#endif
+
 /*
  * Why should I request the Status IU before sending the Command IU?  Spec
  * says to, but also says the device may receive them in any order.  Seems
  * daft to me.
  */
 
-static int uas_submit_urbs(struct scsi_cmnd *cmnd,
-					struct uas_dev_info *devinfo, gfp_t gfp)
+static int uas_submit_sense_urb(struct Scsi_Host *shost,
+				gfp_t gfp, unsigned int stream)
 {
-	struct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;
+	struct uas_dev_info *devinfo = (void *)shost->hostdata[0];
+	struct urb *urb;
 
-	if (cmdinfo->state & ALLOC_STATUS_URB) {
-		cmdinfo->status_urb = uas_alloc_sense_urb(devinfo, gfp, cmnd,
-							  cmdinfo->stream);
-		if (!cmdinfo->status_urb)
-			return SCSI_MLQUEUE_DEVICE_BUSY;
-		cmdinfo->state &= ~ALLOC_STATUS_URB;
+	urb = uas_alloc_sense_urb(devinfo, gfp, shost, stream);
+	if (!urb)
+		return SCSI_MLQUEUE_DEVICE_BUSY;
+	if (usb_submit_urb(urb, gfp)) {
+		shost_printk(KERN_INFO, shost,
+			     "sense urb submission failure\n");
+		usb_free_urb(urb);
+		return SCSI_MLQUEUE_DEVICE_BUSY;
 	}
+	usb_anchor_urb(urb, &devinfo->sense_urbs);
+	return 0;
+}
+
+static int uas_submit_urbs(struct scsi_cmnd *cmnd,
+			   struct uas_dev_info *devinfo, gfp_t gfp)
+{
+	struct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;
+	int err;
 
 	if (cmdinfo->state & SUBMIT_STATUS_URB) {
-		if (usb_submit_urb(cmdinfo->status_urb, gfp)) {
-			scmd_printk(KERN_INFO, cmnd,
-					"sense urb submission failure\n");
-			return SCSI_MLQUEUE_DEVICE_BUSY;
+		err = uas_submit_sense_urb(cmnd->device->host, gfp,
+					   cmdinfo->stream);
+		if (err) {
+			return err;
 		}
 		cmdinfo->state &= ~SUBMIT_STATUS_URB;
 	}
@@ -380,7 +691,7 @@ static int uas_submit_urbs(struct scsi_cmnd *cmnd,
 	if (cmdinfo->state & ALLOC_DATA_IN_URB) {
 		cmdinfo->data_in_urb = uas_alloc_data_urb(devinfo, gfp,
 					devinfo->data_in_pipe, cmdinfo->stream,
-					scsi_in(cmnd), DMA_FROM_DEVICE);
+					cmnd, DMA_FROM_DEVICE);
 		if (!cmdinfo->data_in_urb)
 			return SCSI_MLQUEUE_DEVICE_BUSY;
 		cmdinfo->state &= ~ALLOC_DATA_IN_URB;
@@ -393,12 +704,14 @@ static int uas_submit_urbs(struct scsi_cmnd *cmnd,
 			return SCSI_MLQUEUE_DEVICE_BUSY;
 		}
 		cmdinfo->state &= ~SUBMIT_DATA_IN_URB;
+		cmdinfo->state |= DATA_IN_URB_INFLIGHT;
+		usb_anchor_urb(cmdinfo->data_in_urb, &devinfo->data_urbs);
 	}
 
 	if (cmdinfo->state & ALLOC_DATA_OUT_URB) {
 		cmdinfo->data_out_urb = uas_alloc_data_urb(devinfo, gfp,
 					devinfo->data_out_pipe, cmdinfo->stream,
-					scsi_out(cmnd), DMA_TO_DEVICE);
+					cmnd, DMA_TO_DEVICE);
 		if (!cmdinfo->data_out_urb)
 			return SCSI_MLQUEUE_DEVICE_BUSY;
 		cmdinfo->state &= ~ALLOC_DATA_OUT_URB;
@@ -411,51 +724,127 @@ static int uas_submit_urbs(struct scsi_cmnd *cmnd,
 			return SCSI_MLQUEUE_DEVICE_BUSY;
 		}
 		cmdinfo->state &= ~SUBMIT_DATA_OUT_URB;
+		cmdinfo->state |= DATA_OUT_URB_INFLIGHT;
+		usb_anchor_urb(cmdinfo->data_out_urb, &devinfo->data_urbs);
 	}
 
 	if (cmdinfo->state & ALLOC_CMD_URB) {
 		cmdinfo->cmd_urb = uas_alloc_cmd_urb(devinfo, gfp, cmnd,
-							cmdinfo->stream);
+						     cmdinfo->stream);
 		if (!cmdinfo->cmd_urb)
 			return SCSI_MLQUEUE_DEVICE_BUSY;
 		cmdinfo->state &= ~ALLOC_CMD_URB;
 	}
 
 	if (cmdinfo->state & SUBMIT_CMD_URB) {
+		usb_get_urb(cmdinfo->cmd_urb);
 		if (usb_submit_urb(cmdinfo->cmd_urb, gfp)) {
+			usb_put_urb(cmdinfo->cmd_urb);
 			scmd_printk(KERN_INFO, cmnd,
 					"cmd urb submission failure\n");
 			return SCSI_MLQUEUE_DEVICE_BUSY;
 		}
+		usb_anchor_urb(cmdinfo->cmd_urb, &devinfo->cmd_urbs);
+		usb_put_urb(cmdinfo->cmd_urb);
+		cmdinfo->cmd_urb = NULL;
 		cmdinfo->state &= ~SUBMIT_CMD_URB;
+		cmdinfo->state |= COMMAND_INFLIGHT;
 	}
 
 	return 0;
 }
 
+/* To Report "Illegal Request: Invalid Field in CDB" */
+static unsigned char uas_sense_invalidCDB[18] = {
+	[0] = 0x70,				/* current error */
+	[2] = ILLEGAL_REQUEST,	/* Illegal Request = 0x05 */
+	[7] = 0x0a,				/* additional length */
+	[12] = 0x24				/* Invalid Field in CDB */
+};
+
+static int uas_prev_queue_command(struct scsi_cmnd *cmnd)
+{
+	struct scsi_device *sdev = cmnd->device;
+	struct uas_dev_info *devinfo = sdev->hostdata;
+	int ret = -EINVAL;
+
+	switch (cmnd->cmnd[0]) {
+	case ATA_12:
+	case ATA_16:
+		if (devinfo->quirks & UAS_NO_ATA_PASS_THRU) {
+			scmd_printk(KERN_DEBUG, cmnd, "reject cmd:%p (0x%02x)\n",
+				cmnd, cmnd->cmnd[0]);
+			cmnd->result = SAM_STAT_CHECK_CONDITION;
+			memcpy(cmnd->sense_buffer, uas_sense_invalidCDB, sizeof(uas_sense_invalidCDB));
+			ret = 0;
+		}
+		break;
+	case TEST_UNIT_READY:
+		if (devinfo->quirks & UAS_NO_TEST_UNIT_READY) {
+			scmd_printk(KERN_DEBUG, cmnd, "ignore cmd:%p (0x%02x)\n",
+				cmnd, cmnd->cmnd[0]);
+			cmnd->result = SAM_STAT_GOOD;
+			ret = 0;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,36))
 static int uas_queuecommand_lck(struct scsi_cmnd *cmnd,
 					void (*done)(struct scsi_cmnd *))
+#else
+static int uas_queuecommand(struct scsi_cmnd *cmnd,
+					void (*done)(struct scsi_cmnd *))
+#endif
 {
 	struct scsi_device *sdev = cmnd->device;
 	struct uas_dev_info *devinfo = sdev->hostdata;
 	struct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;
+	unsigned long flags;
 	int err;
 
 	BUILD_BUG_ON(sizeof(struct uas_cmd_info) > sizeof(struct scsi_pointer));
 
-	if (!cmdinfo->status_urb && sdev->current_cmnd)
+	if (test_bit(UAS_FLIDX_DISCONNECTING, &devinfo->flags)) {
+		scmd_printk(KERN_DEBUG, cmnd, "fail cmd:%p (0x%02x) during disconnect\n",
+			cmnd, cmnd->cmnd[0]);
+		cmnd->result = DID_NO_CONNECT << 16;
+		goto err_done;
+	}
+
+	if (test_bit(UAS_FLIDX_RESETTING, &devinfo->flags)) {
+		scmd_printk(KERN_DEBUG, cmnd, "fail cmd:%p (0x%02x) during reset\n",
+			cmnd, cmnd->cmnd[0]);
+		cmnd->result = DID_ERROR << 16;
+		goto err_done;
+	}
+
+	if (!uas_prev_queue_command(cmnd)) {
+		goto err_done;
+	}
+
+	spin_lock_irqsave(&devinfo->lock, flags);
+	if (devinfo->cmnd) {
+		spin_unlock_irqrestore(&devinfo->lock, flags);
 		return SCSI_MLQUEUE_DEVICE_BUSY;
+	}
 
 	if (blk_rq_tagged(cmnd->request)) {
-		cmdinfo->stream = cmnd->request->tag + 1;
+		cmdinfo->stream = cmnd->request->tag + UAS_CMD_TAG_OFFS;
 	} else {
-		sdev->current_cmnd = cmnd;
-		cmdinfo->stream = 1;
+		devinfo->cmnd = cmnd;
+		cmdinfo->stream = UAS_CMD_UNTAGGED_TAG;
 	}
 
 	cmnd->scsi_done = done;
 
-	cmdinfo->state = ALLOC_STATUS_URB | SUBMIT_STATUS_URB |
+	INIT_LIST_HEAD(&cmdinfo->list);
+	cmdinfo->state = SUBMIT_STATUS_URB |
 			ALLOC_CMD_URB | SUBMIT_CMD_URB;
 
 	switch (cmnd->sc_data_direction) {
@@ -470,7 +859,7 @@ static int uas_queuecommand_lck(struct scsi_cmnd *cmnd,
 		break;
 	}
 
-	if (!devinfo->use_streams) {
+	if (!test_bit(UAS_FLIDX_USE_STREAMS, &devinfo->flags)) {
 		cmdinfo->state &= ~(SUBMIT_DATA_IN_URB | SUBMIT_DATA_OUT_URB);
 		cmdinfo->stream = 0;
 	}
@@ -479,50 +868,113 @@ static int uas_queuecommand_lck(struct scsi_cmnd *cmnd,
 	if (err) {
 		/* If we did nothing, give up now */
 		if (cmdinfo->state & SUBMIT_STATUS_URB) {
-			usb_free_urb(cmdinfo->status_urb);
+			spin_unlock_irqrestore(&devinfo->lock, flags);
 			return SCSI_MLQUEUE_DEVICE_BUSY;
 		}
 		spin_lock(&uas_work_lock);
 		list_add_tail(&cmdinfo->list, &uas_work_list);
+		cmdinfo->state |= IS_IN_WORK_LIST;
 		spin_unlock(&uas_work_lock);
 		schedule_work(&uas_work);
 	}
 
+	spin_unlock_irqrestore(&devinfo->lock, flags);
+	return 0;
+
+err_done:
+	done(cmnd);
 	return 0;
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,36))
 static DEF_SCSI_QCMD(uas_queuecommand)
+#endif
 
-static int uas_eh_abort_handler(struct scsi_cmnd *cmnd)
+static int uas_eh_task_mgmt(struct scsi_cmnd *cmnd,
+			    const char *fname, u8 function)
 {
-	struct scsi_device *sdev = cmnd->device;
-	sdev_printk(KERN_INFO, sdev, "%s tag %d\n", __func__,
-							cmnd->request->tag);
+#if defined(CONFIG_USB_UAS_ENABLE_TASK_MANAGEMENT)
+	struct Scsi_Host *shost = cmnd->device->host;
+	struct uas_dev_info *devinfo = (void *)shost->hostdata[0];
+	u16 tag = UAS_TMF_TAG;
+	unsigned long flags;
+
+	spin_lock_irqsave(&devinfo->lock, flags);
+	memset(&devinfo->response, 0, sizeof(devinfo->response));
+	if (uas_submit_sense_urb(shost, GFP_ATOMIC, tag)) {
+		shost_printk(KERN_INFO, shost,
+			     "%s: %s: submit sense urb failed\n",
+			     __func__, fname);
+		spin_unlock_irqrestore(&devinfo->lock, flags);
+		return FAILED;
+	}
+	if (uas_submit_task_urb(cmnd, GFP_ATOMIC, function, tag)) {
+		shost_printk(KERN_INFO, shost,
+			     "%s: %s: submit task mgmt urb failed\n",
+			     __func__, fname);
+		spin_unlock_irqrestore(&devinfo->lock, flags);
+		return FAILED;
+	}
+	spin_unlock_irqrestore(&devinfo->lock, flags);
 
-/* XXX: Send ABORT TASK Task Management command */
+	if (usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 3000) == 0) {
+		shost_printk(KERN_INFO, shost,
+			     "%s: %s timed out\n", __func__, fname);
+		return FAILED;
+	}
+	if (be16_to_cpu(devinfo->response.tag) != tag) {
+		shost_printk(KERN_INFO, shost,
+			     "%s: %s failed (wrong tag %d/%d)\n", __func__,
+			     fname, be16_to_cpu(devinfo->response.tag), tag);
+		return FAILED;
+	}
+	if (devinfo->response.response_code != RC_TMF_COMPLETE) {
+		shost_printk(KERN_INFO, shost,
+			     "%s: %s failed (rc 0x%x)\n", __func__,
+			     fname, devinfo->response.response_code);
+		return FAILED;
+	}
+	return SUCCESS;
+#else
 	return FAILED;
+#endif
 }
 
-static int uas_eh_device_reset_handler(struct scsi_cmnd *cmnd)
+static int uas_eh_abort_handler(struct scsi_cmnd *cmnd)
 {
-	struct scsi_device *sdev = cmnd->device;
-	sdev_printk(KERN_INFO, sdev, "%s tag %d\n", __func__,
-							cmnd->request->tag);
+	struct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;
+	struct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;
+	unsigned long flags;
+	int ret;
 
-/* XXX: Send LOGICAL UNIT RESET Task Management command */
-	return FAILED;
+	uas_log_cmd_state(cmnd, __func__);
+	spin_lock_irqsave(&devinfo->lock, flags);
+	cmdinfo->state |= COMMAND_ABORTED;
+	if (cmdinfo->state & IS_IN_WORK_LIST) {
+		spin_lock(&uas_work_lock);
+		list_del(&cmdinfo->list);
+		cmdinfo->state &= ~IS_IN_WORK_LIST;
+		spin_unlock(&uas_work_lock);
+	}
+	if (cmdinfo->state & COMMAND_INFLIGHT) {
+		spin_unlock_irqrestore(&devinfo->lock, flags);
+		ret = uas_eh_task_mgmt(cmnd, "ABORT TASK", TMF_ABORT_TASK);
+	} else {
+		spin_unlock_irqrestore(&devinfo->lock, flags);
+		uas_unlink_data_urbs(devinfo, cmdinfo);
+		spin_lock_irqsave(&devinfo->lock, flags);
+		uas_try_complete(cmnd, __func__);
+		spin_unlock_irqrestore(&devinfo->lock, flags);
+		ret = SUCCESS;
+	}
+	return ret;
 }
 
-static int uas_eh_target_reset_handler(struct scsi_cmnd *cmnd)
+static int uas_eh_device_reset_handler(struct scsi_cmnd *cmnd)
 {
-	struct scsi_device *sdev = cmnd->device;
-	sdev_printk(KERN_INFO, sdev, "%s tag %d\n", __func__,
-							cmnd->request->tag);
-
-/* XXX: Can we reset just the one USB interface?
- * Would calling usb_set_interface() have the right effect?
- */
-	return FAILED;
+	sdev_printk(KERN_INFO, cmnd->device, "%s\n", __func__);
+	return uas_eh_task_mgmt(cmnd, "LOGICAL UNIT RESET",
+				TMF_LOGICAL_UNIT_RESET);
 }
 
 static int uas_eh_bus_reset_handler(struct scsi_cmnd *cmnd)
@@ -530,13 +982,28 @@ static int uas_eh_bus_reset_handler(struct scsi_cmnd *cmnd)
 	struct scsi_device *sdev = cmnd->device;
 	struct uas_dev_info *devinfo = sdev->hostdata;
 	struct usb_device *udev = devinfo->udev;
+	int err;
 
-	sdev_printk(KERN_INFO, sdev, "%s tag %d\n", __func__,
-							cmnd->request->tag);
+	set_bit(UAS_FLIDX_RESETTING, &devinfo->flags);
+	uas_abort_work(devinfo);
+	usb_kill_anchored_urbs(&devinfo->cmd_urbs);
+	usb_kill_anchored_urbs(&devinfo->sense_urbs);
+	usb_kill_anchored_urbs(&devinfo->data_urbs);
+	err = usb_lock_device_for_reset(udev, devinfo->intf);
+	if (!err) {
+		err = usb_reset_device(udev);
+		usb_unlock_device(udev);
 
-	if (usb_reset_device(udev))
-		return SUCCESS;
+		if (!err) {
+			uas_configure_endpoints(devinfo);
+			clear_bit(UAS_FLIDX_RESETTING, &devinfo->flags);
+			shost_printk(KERN_INFO, sdev->host, "%s success\n", __func__);
+			return SUCCESS;
+		}
+	}
 
+	clear_bit(UAS_FLIDX_RESETTING, &devinfo->flags);
+	shost_printk(KERN_INFO, sdev->host, "%s FAILED\n", __func__);
 	return FAILED;
 }
 
@@ -549,8 +1016,9 @@ static int uas_slave_alloc(struct scsi_device *sdev)
 static int uas_slave_configure(struct scsi_device *sdev)
 {
 	struct uas_dev_info *devinfo = sdev->hostdata;
+	blk_queue_rq_timeout(sdev->request_queue, 5 * HZ);
 	scsi_set_tag_type(sdev, MSG_ORDERED_TAG);
-	scsi_activate_tcq(sdev, devinfo->qdepth - 1);
+	scsi_activate_tcq(sdev, devinfo->qdepth);
 	return 0;
 }
 
@@ -562,7 +1030,6 @@ static struct scsi_host_template uas_host_template = {
 	.slave_configure = uas_slave_configure,
 	.eh_abort_handler = uas_eh_abort_handler,
 	.eh_device_reset_handler = uas_eh_device_reset_handler,
-	.eh_target_reset_handler = uas_eh_target_reset_handler,
 	.eh_bus_reset_handler = uas_eh_bus_reset_handler,
 	.can_queue = 65536,	/* Is there a limit on the _host_ ? */
 	.this_id = -1,
@@ -573,6 +1040,11 @@ static struct scsi_host_template uas_host_template = {
 };
 
 static struct usb_device_id uas_usb_ids[] = {
+	{ USB_DEVICE_VER(0x4971, 0x1012, 0x4798, 0x4798), .driver_info = UAS_INCOMPATIBLE_DEVICE },
+	{ USB_DEVICE_VER(0x05e3, 0x0733, 0x5405, 0x5405), .driver_info = UAS_INCOMPATIBLE_DEVICE },
+	{ USB_DEVICE_VER(0x059b, 0x0070, 0x0006, 0x0006), .driver_info = UAS_INCOMPATIBLE_DEVICE },
+	{ USB_DEVICE_VER(0x1759, 0x5002, 0x2270, 0x2270), .driver_info = UAS_NO_TEST_UNIT_READY },
+	{ USB_DEVICE_VER(0x2109, 0x0711, 0x0200, 0x0200), .driver_info = UAS_NO_ATA_PASS_THRU },
 	{ USB_INTERFACE_INFO(USB_CLASS_MASS_STORAGE, USB_SC_SCSI, USB_PR_BULK) },
 	{ USB_INTERFACE_INFO(USB_CLASS_MASS_STORAGE, USB_SC_SCSI, USB_PR_UAS) },
 	/* 0xaa is a prototype device I happen to have access to */
@@ -588,27 +1060,64 @@ static int uas_is_interface(struct usb_host_interface *intf)
 		intf->desc.bInterfaceProtocol == USB_PR_UAS);
 }
 
+static int uas_isnt_supported(struct usb_device *udev)
+{
+	struct usb_hcd *hcd = bus_to_hcd(udev->bus);
+
+	dev_warn(&udev->dev, "The driver for the USB controller %s does not "
+			"support scatter-gather which is\n",
+			hcd->driver->description);
+	dev_warn(&udev->dev, "required by the UAS driver. Please try an"
+			"alternative USB controller if you wish to use UAS.\n");
+	return -ENODEV;
+}
+
 static int uas_switch_interface(struct usb_device *udev,
 						struct usb_interface *intf)
 {
 	int i;
-
-	if (uas_is_interface(intf->cur_altsetting))
-		return 0;
+	int sg_supported = udev->bus->sg_tablesize != 0;
 
 	for (i = 0; i < intf->num_altsetting; i++) {
 		struct usb_host_interface *alt = &intf->altsetting[i];
-		if (alt == intf->cur_altsetting)
-			continue;
-		if (uas_is_interface(alt))
+
+		if (uas_is_interface(alt)) {
+			if (!sg_supported)
+				return uas_isnt_supported(udev);
 			return usb_set_interface(udev,
 						alt->desc.bInterfaceNumber,
 						alt->desc.bAlternateSetting);
+		}
 	}
 
 	return -ENODEV;
 }
 
+static void uas_set_queue_depth(struct uas_dev_info *devinfo)
+{
+	int qdepth;
+
+	/* Define the following cmd tag assignment:
+	 * [1:TMF, 2:untagged, [3, num_streams]:tagged].
+	 * Thus there are num_streams-3+1 = num_streams-2 tags
+	 * for tagged commands. Report this number to the SCSI Core
+	 * as the number of maximum commands we can queue, thus
+	 * giving us a tag range [0, num_streams-3], which we
+	 * offset by 3 (CMD_TAG_OFFS).
+	 */
+	qdepth = devinfo->num_streams - 2;
+	if (qdepth <= 0) {
+		/* Pathological case--perhaps fail discovery?
+		 */
+		dev_notice(&devinfo->udev->dev,
+				"device supports too few streams (%d)\n",
+				devinfo->num_streams);
+		qdepth = max(1, devinfo->num_streams - 1);
+	}
+
+	devinfo->qdepth = qdepth;
+}
+
 static void uas_configure_endpoints(struct uas_dev_info *devinfo)
 {
 	struct usb_host_endpoint *eps[4] = { };
@@ -616,12 +1125,24 @@ static void uas_configure_endpoints(struct uas_dev_info *devinfo)
 	struct usb_device *udev = devinfo->udev;
 	struct usb_host_endpoint *endpoint = intf->cur_altsetting->endpoint;
 	unsigned i, n_endpoints = intf->cur_altsetting->desc.bNumEndpoints;
+	unsigned char *extra;
+	int len;
 
-	devinfo->uas_sense_old = 0;
+	devinfo->cmnd = NULL;
 
 	for (i = 0; i < n_endpoints; i++) {
-		unsigned char *extra = endpoint[i].extra;
-		int len = endpoint[i].extralen;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+		struct usb_host_ss_ep_comp *comp = endpoint[i].ss_ep_comp;
+
+		if (!comp)
+			continue;
+
+		extra = comp->extra;
+		len = comp->extralen;
+#else		
+		extra = endpoint[i].extra;
+		len = endpoint[i].extralen;
+#endif
 		while (len > 1) {
 			if (extra[1] == USB_DT_PIPE_USAGE) {
 				unsigned pipe_id = extra[2];
@@ -659,16 +1180,73 @@ static void uas_configure_endpoints(struct uas_dev_info *devinfo)
 						eps[3]->desc.bEndpointAddress);
 	}
 
-	devinfo->qdepth = usb_alloc_streams(devinfo->intf, eps + 1, 3, 256,
+	devinfo->num_streams = usb_alloc_streams(devinfo->intf, eps + 1, 3, 256,
 								GFP_KERNEL);
-	if (devinfo->qdepth < 0) {
+	if (devinfo->num_streams < 0) {
 		devinfo->qdepth = 256;
-		devinfo->use_streams = 0;
+		clear_bit(UAS_FLIDX_USE_STREAMS, &devinfo->flags);
 	} else {
-		devinfo->use_streams = 1;
+		uas_set_queue_depth(devinfo);
+		set_bit(UAS_FLIDX_USE_STREAMS, &devinfo->flags);
+		dev_info(&udev->dev, "%s: allocated streams %d\n", __func__, devinfo->num_streams);
 	}
 }
 
+static void uas_free_streams(struct uas_dev_info *devinfo)
+{
+	struct usb_device *udev = devinfo->udev;
+	struct usb_host_endpoint *eps[3];
+
+	eps[0] = usb_pipe_endpoint(udev, devinfo->status_pipe);
+	eps[1] = usb_pipe_endpoint(udev, devinfo->data_in_pipe);
+	eps[2] = usb_pipe_endpoint(udev, devinfo->data_out_pipe);
+	usb_free_streams(devinfo->intf, eps, 3, GFP_KERNEL);
+}
+
+static int uas_is_hcd_support_stream(struct usb_device *udev)
+{
+	struct usb_hcd *hcd = bus_to_hcd(udev->bus);
+	int ret = -ENODEV;
+
+	switch (hcd->chip_id) {
+	case HCD_CHIP_ID_ETRON_EJ168:
+	case HCD_CHIP_ID_ETRON_EJ188:
+		ret = 0;
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static void uas_adjust_quirks(struct uas_dev_info *devinfo, const struct usb_device_id *id)
+{
+	unsigned long mask = (UAS_SENSE_IU_R01 | UAS_SENSE_IU_R02 | UAS_SENSE_IU_2R00 |
+			UAS_NO_ATA_PASS_THRU | UAS_NO_TEST_UNIT_READY);
+
+	devinfo->quirks = id->driver_info & mask;
+	if (devinfo->quirks)		
+		dev_info(&devinfo->udev->dev, "%s: quirks = 0x%08lx\n", __func__, devinfo->quirks);
+}
+
+static int uas_is_incompatible_device(struct usb_device *udev, const struct usb_device_id *id)
+{
+#define USB_QUIRK_BOT_MODE		0x40000000
+
+	if (udev->speed != USB_SPEED_SUPER)
+		return 0;
+	else if (udev->quirks & USB_QUIRK_BOT_MODE)
+		return 0;
+	else if (id->driver_info & UAS_INCOMPATIBLE_DEVICE) {
+		usb_set_device_state(udev, USB_STATE_NOTATTACHED);
+		usb_run_bot_mode_notification(udev->parent, udev->portnum);
+		return 0;
+	}
+
+	return -ENODEV;
+}
+
 /*
  * XXX: What I'd like to do here is register a SCSI host for each USB host in
  * the system.  Follow usb-storage's design of registering a SCSI host for
@@ -682,10 +1260,17 @@ static int uas_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	struct uas_dev_info *devinfo;
 	struct usb_device *udev = interface_to_usbdev(intf);
 
+	if (uas_is_hcd_support_stream(udev))
+		return -ENODEV;
+
+	if (!uas_is_incompatible_device(udev, id))
+		return -ENODEV;
+
 	if (uas_switch_interface(udev, intf))
 		return -ENODEV;
 
-	devinfo = kmalloc(sizeof(struct uas_dev_info), GFP_KERNEL);
+	dev_info(&udev->dev, "UAS device detected\n");
+	devinfo = kzalloc(sizeof(struct uas_dev_info), GFP_KERNEL);
 	if (!devinfo)
 		return -ENOMEM;
 
@@ -698,18 +1283,36 @@ static int uas_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	shost->max_id = 1;
 	shost->sg_tablesize = udev->bus->sg_tablesize;
 
-	result = scsi_add_host(shost, &intf->dev);
-	if (result)
-		goto free;
-	shost->hostdata[0] = (unsigned long)devinfo;
-
 	devinfo->intf = intf;
 	devinfo->udev = udev;
+	init_usb_anchor(&devinfo->cmd_urbs);
+	init_usb_anchor(&devinfo->sense_urbs);
+	init_usb_anchor(&devinfo->data_urbs);
+	spin_lock_init(&devinfo->lock);
+	uas_adjust_quirks(devinfo, id);
+	uas_update_uas_device(intf, UAS_PROBE);
 	uas_configure_endpoints(devinfo);
 
+	shost->can_queue = devinfo->qdepth;
+	shost->cmd_per_lun = devinfo->qdepth;
+
+	result = scsi_init_shared_tag_map(shost, devinfo->qdepth);
+	if (result)
+		goto deconfig_eps;
+
+	result = scsi_add_host(shost, &intf->dev);
+	if (result)
+		goto deconfig_eps;
+
+	shost->hostdata[0] = (unsigned long)devinfo;
+
 	scsi_scan_host(shost);
 	usb_set_intfdata(intf, shost);
 	return result;
+
+deconfig_eps:
+	uas_free_streams(devinfo);
+	uas_update_uas_device(intf, UAS_DISCONNECT);
  free:
 	kfree(devinfo);
 	if (shost)
@@ -720,29 +1323,30 @@ static int uas_probe(struct usb_interface *intf, const struct usb_device_id *id)
 static int uas_pre_reset(struct usb_interface *intf)
 {
 /* XXX: Need to return 1 if it's not our device in error handling */
+	uas_update_uas_device(intf, UAS_PREV_RESET);
 	return 0;
 }
 
 static int uas_post_reset(struct usb_interface *intf)
 {
 /* XXX: Need to return 1 if it's not our device in error handling */
+	uas_update_uas_device(intf, UAS_POST_RESET);
 	return 0;
 }
 
 static void uas_disconnect(struct usb_interface *intf)
 {
-	struct usb_device *udev = interface_to_usbdev(intf);
-	struct usb_host_endpoint *eps[3];
 	struct Scsi_Host *shost = usb_get_intfdata(intf);
 	struct uas_dev_info *devinfo = (void *)shost->hostdata[0];
 
+	set_bit(UAS_FLIDX_DISCONNECTING, &devinfo->flags);
+	uas_abort_work(devinfo);
+	usb_kill_anchored_urbs(&devinfo->cmd_urbs);
+	usb_kill_anchored_urbs(&devinfo->sense_urbs);
+	usb_kill_anchored_urbs(&devinfo->data_urbs);
 	scsi_remove_host(shost);
-
-	eps[0] = usb_pipe_endpoint(udev, devinfo->status_pipe);
-	eps[1] = usb_pipe_endpoint(udev, devinfo->data_in_pipe);
-	eps[2] = usb_pipe_endpoint(udev, devinfo->data_out_pipe);
-	usb_free_streams(intf, eps, 3, GFP_KERNEL);
-
+	uas_free_streams(devinfo);
+	uas_update_uas_device(intf, UAS_DISCONNECT);
 	kfree(devinfo);
 }
 
@@ -759,6 +1363,9 @@ static struct usb_driver uas_driver = {
 	.id_table = uas_usb_ids,
 };
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(3,3,0))
+module_usb_driver(uas_driver);
+#else
 static int uas_init(void)
 {
 	return usb_register(&uas_driver);
@@ -771,6 +1378,7 @@ static void uas_exit(void)
 
 module_init(uas_init);
 module_exit(uas_exit);
+#endif
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Matthew Wilcox and Sarah Sharp");
diff --git a/src/drivers/usb/storage/usb.c b/src/drivers/usb/storage/usb.c
index 4219c19..f24ac45 100644
--- a/src/drivers/usb/storage/usb.c
+++ b/src/drivers/usb/storage/usb.c
@@ -58,6 +58,8 @@
 #include <linux/kthread.h>
 #include <linux/mutex.h>
 #include <linux/utsname.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
 
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
@@ -86,7 +88,6 @@ static char quirks[128];
 module_param_string(quirks, quirks, sizeof(quirks), S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(quirks, "supplemental list of device IDs and their quirks");
 
-
 /*
  * The entries in this table correspond, line for line,
  * with the entries in usb_storage_usb_ids[], defined in usual-tables.c.
@@ -261,6 +262,20 @@ void fill_inquiry_response(struct us_data *us, unsigned char *data,
 }
 EXPORT_SYMBOL_GPL(fill_inquiry_response);
 
+static int usb_stor_no_test_unit_ready(struct us_data *us)
+{
+	struct usb_device *udev = us->pusb_dev;
+
+	if (us->srb->cmnd[0] != TEST_UNIT_READY)
+		return -EINVAL;
+
+	if (udev->descriptor.idVendor != cpu_to_le16(0x1759) ||
+		udev->descriptor.idProduct != cpu_to_le16(0x5002))
+		return -EINVAL;
+
+	return 0;
+}
+
 static int usb_stor_control_thread(void * __us)
 {
 	struct us_data *us = (struct us_data *)__us;
@@ -332,6 +347,11 @@ static int usb_stor_control_thread(void * __us)
 			us->srb->result = SAM_STAT_GOOD;
 		}
 
+		else if (!usb_stor_no_test_unit_ready(us)) {
+			US_DEBUGP("Ignoring TEST_UNIT_READY command\n");
+			us->srb->result = SAM_STAT_GOOD;
+		}
+
 		/* we've got a command, let's do it! */
 		else {
 			US_DEBUG(usb_stor_show_command(us->srb));
@@ -994,6 +1014,17 @@ void usb_stor_disconnect(struct usb_interface *intf)
 }
 EXPORT_SYMBOL_GPL(usb_stor_disconnect);
 
+#if defined(CONFIG_USB_UAS) || defined(CONFIG_USB_UAS_MODULE)
+static int is_uas_device(struct usb_interface *intf)
+{
+	struct usb_device *udev = interface_to_usbdev(intf);
+
+#define USB_QUIRK_UAS_MODE		0x80000000
+
+	return !!(udev->quirks & USB_QUIRK_UAS_MODE);
+}
+#endif
+
 /* The main probe routine for standard devices */
 static int storage_probe(struct usb_interface *intf,
 			 const struct usb_device_id *id)
@@ -1001,6 +1032,11 @@ static int storage_probe(struct usb_interface *intf,
 	struct us_data *us;
 	int result;
 
+#if defined(CONFIG_USB_UAS) || defined(CONFIG_USB_UAS_MODULE)
+	if (is_uas_device(intf))
+		return -ENODEV;
+#endif
+
 	/*
 	 * If libusual is configured, let it decide whether a standard
 	 * device should be handled by usb-storage or by ub.
diff --git a/src/include/linux/usb/ch11.h b/src/include/linux/usb/ch11.h
index 4ebaf08..0c44f9a 100644
--- a/src/include/linux/usb/ch11.h
+++ b/src/include/linux/usb/ch11.h
@@ -26,7 +26,6 @@
 #define HUB_RESET_TT		9
 #define HUB_GET_TT_STATE	10
 #define HUB_STOP_TT		11
-#define HUB_SET_DEPTH		12
 
 /*
  * Hub class additional requests defined by USB 3.0 spec
@@ -62,12 +61,6 @@
 #define USB_PORT_FEAT_TEST              21
 #define USB_PORT_FEAT_INDICATOR         22
 #define USB_PORT_FEAT_C_PORT_L1         23
-#define USB_PORT_FEAT_C_PORT_LINK_STATE	25
-#define USB_PORT_FEAT_C_PORT_CONFIG_ERROR 26
-#define USB_PORT_FEAT_PORT_REMOTE_WAKE_MASK 27
-#define USB_PORT_FEAT_BH_PORT_RESET     28
-#define USB_PORT_FEAT_C_BH_PORT_RESET   29
-#define USB_PORT_FEAT_FORCE_LINKPM_ACCEPT 30
 
 /*
  * Port feature selectors added by USB 3.0 spec.
@@ -76,13 +69,18 @@
 #define USB_PORT_FEAT_LINK_STATE		5
 #define USB_PORT_FEAT_U1_TIMEOUT		23
 #define USB_PORT_FEAT_U2_TIMEOUT		24
-#define USB_PORT_FEAT_C_LINK_STATE		25
-#define USB_PORT_FEAT_C_CONFIG_ERR		26
+#define USB_PORT_FEAT_C_PORT_LINK_STATE		25
+#define USB_PORT_FEAT_C_PORT_CONFIG_ERROR	26
 #define USB_PORT_FEAT_REMOTE_WAKE_MASK		27
 #define USB_PORT_FEAT_BH_PORT_RESET		28
 #define USB_PORT_FEAT_C_BH_PORT_RESET		29
 #define USB_PORT_FEAT_FORCE_LINKPM_ACCEPT	30
 
+/* USB 3.0 hub remote wake mask bits, see table 10-14 */
+#define USB_PORT_FEAT_REMOTE_WAKE_CONNECT	(1 << 8)
+#define USB_PORT_FEAT_REMOTE_WAKE_DISCONNECT	(1 << 9)
+#define USB_PORT_FEAT_REMOTE_WAKE_OVER_CURRENT	(1 << 10)
+
 /*
  * Hub Status and Hub Change results
  * See USB 2.0 spec Table 11-19 and Table 11-20
@@ -165,11 +163,20 @@ struct usb_port_status {
  * wHubCharacteristics (masks)
  * See USB 2.0 spec Table 11-13, offset 3
  */
-#define HUB_CHAR_LPSM		0x0003 /* D1 .. D0 */
-#define HUB_CHAR_COMPOUND	0x0004 /* D2       */
-#define HUB_CHAR_OCPM		0x0018 /* D4 .. D3 */
-#define HUB_CHAR_TTTT           0x0060 /* D6 .. D5 */
-#define HUB_CHAR_PORTIND        0x0080 /* D7       */
+#define HUB_CHAR_LPSM		0x0003 /* Logical Power Switching Mode mask */
+#define HUB_CHAR_COMMON_LPSM	0x0000 /* All ports power control at once */
+#define HUB_CHAR_INDV_PORT_LPSM	0x0001 /* per-port power control */
+#define HUB_CHAR_NO_LPSM	0x0002 /* no power switching */
+
+#define HUB_CHAR_COMPOUND	0x0004 /* hub is part of a compound device */
+
+#define HUB_CHAR_OCPM		0x0018 /* Over-Current Protection Mode mask */
+#define HUB_CHAR_COMMON_OCPM	0x0000 /* All ports Over-Current reporting */
+#define HUB_CHAR_INDV_PORT_OCPM	0x0008 /* per-port Over-current reporting */
+#define HUB_CHAR_NO_OCPM	0x0010 /* No Over-current Protection support */
+
+#define HUB_CHAR_TTTT		0x0060 /* TT Think Time mask */
+#define HUB_CHAR_PORTIND	0x0080 /* per-port indicators (LEDs) */
 
 struct usb_hub_status {
 	__le16 wHubStatus;
@@ -198,6 +205,17 @@ struct usb_hub_status {
 #define USB_DT_HUB_NONVAR_SIZE		7
 #define USB_DT_SS_HUB_SIZE              12
 
+/*
+ * Hub Device descriptor
+ * USB Hub class device protocols
+ */
+
+#define USB_HUB_PR_FS		0 /* Full speed hub */
+#define USB_HUB_PR_HS_NO_TT	0 /* Hi-speed hub without TT */
+#define USB_HUB_PR_HS_SINGLE_TT	1 /* Hi-speed hub with single TT */
+#define USB_HUB_PR_HS_MULTI_TT	2 /* Hi-speed hub with multiple TT */
+#define USB_HUB_PR_SS		3 /* Super speed hub */
+
 struct usb_hub_descriptor {
 	__u8  bDescLength;
 	__u8  bDescriptorType;
@@ -216,8 +234,8 @@ struct usb_hub_descriptor {
 
 		struct {
 			__u8 bHubHdrDecLat;
-			__u16 wHubDelay;
-			__u16 DeviceRemovable;
+			__le16 wHubDelay;
+			__le16 DeviceRemovable;
 		}  __attribute__ ((packed)) ss;
 	} u;
 } __attribute__ ((packed));
diff --git a/src/include/linux/usb/ch9.h b/src/include/linux/usb/ch9.h
index b72f305..47c154b 100644
--- a/src/include/linux/usb/ch9.h
+++ b/src/include/linux/usb/ch9.h
@@ -34,6 +34,7 @@
 #define __LINUX_USB_CH9_H
 
 #include <linux/types.h>	/* __u8 etc */
+#include <asm/byteorder.h>	/* le16_to_cpu */
 
 /*-------------------------------------------------------------------------*/
 
@@ -143,6 +144,11 @@
 #define USB_INTRF_FUNC_SUSPEND	0	/* function suspend */
 
 #define USB_INTR_FUNC_SUSPEND_OPT_MASK	0xFF00
+/*
+ * Suspend Options, Table 9-7 USB 3.0 spec
+ */
+#define USB_INTRF_FUNC_SUSPEND_LP	(1 << (8 + 0))
+#define USB_INTRF_FUNC_SUSPEND_RW	(1 << (8 + 1))
 
 #define USB_ENDPOINT_HALT		0	/* IN/OUT will STALL */
 
@@ -570,6 +576,17 @@ static inline int usb_endpoint_is_isoc_out(
 	return usb_endpoint_xfer_isoc(epd) && usb_endpoint_dir_out(epd);
 }
 
+/**
+ * usb_endpoint_maxp - get endpoint's max packet size
+ * @epd: endpoint to be checked
+ *
+ * Returns @epd's max packet
+ */
+static inline int usb_endpoint_maxp(const struct usb_endpoint_descriptor *epd)
+{
+	return __le16_to_cpu(epd->wMaxPacketSize);
+}
+
 /*-------------------------------------------------------------------------*/
 
 /* USB_DT_SS_ENDPOINT_COMP: SuperSpeed Endpoint Companion descriptor */
@@ -579,7 +596,7 @@ struct usb_ss_ep_comp_descriptor {
 
 	__u8  bMaxBurst;
 	__u8  bmAttributes;
-	__u16 wBytesPerInterval;
+	__le16 wBytesPerInterval;
 } __attribute__ ((packed));
 
 #define USB_DT_SS_EP_COMP_SIZE		6
diff --git a/src/include/linux/usb/hcd.h b/src/include/linux/usb/hcd.h
index 0097136..398bd74 100644
--- a/src/include/linux/usb/hcd.h
+++ b/src/include/linux/usb/hcd.h
@@ -168,6 +168,14 @@ struct usb_hcd {
 #define	HC_IS_RUNNING(state) ((state) & __ACTIVE)
 #define	HC_IS_SUSPENDED(state) ((state) & __SUSPEND)
 
+	u8		chip_id;
+#define HCD_CHIP_ID_UNKNOWN 0x00
+#define HCD_CHIP_ID_ETRON_EJ168 0x10
+#define HCD_CHIP_ID_ETRON_EJ188 0x20
+
+	unsigned int		chip_quirks;
+#define HCD_BATTERY_CHARGE_QUIRK (1 << 0)
+
 	/* more shared queuing code would be good; it should support
 	 * smarter scheduling, handle transaction translators, etc;
 	 * input size of periodic table to an interrupt scheduler.
@@ -343,6 +351,9 @@ struct hc_driver {
 		 * address is set
 		 */
 	int	(*update_device)(struct usb_hcd *, struct usb_device *);
+	int	(*update_uas_device)(struct usb_hcd *, struct usb_device *, int);
+	void	(*stop_endpoint)(struct usb_hcd *, struct usb_device *,
+				struct usb_host_endpoint *);
 };
 
 extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb);
@@ -413,6 +424,8 @@ extern irqreturn_t usb_hcd_irq(int irq, void *__hcd);
 
 extern void usb_hc_died(struct usb_hcd *hcd);
 extern void usb_hcd_poll_rh_status(struct usb_hcd *hcd);
+extern void usb_wakeup_notification(struct usb_device *hdev,
+		unsigned int portnum);
 
 /* The D0/D1 toggle bits ... USE WITH CAUTION (they're almost hcd-internal) */
 #define usb_gettoggle(dev, ep, out) (((dev)->toggle[out] >> (ep)) & 1)
